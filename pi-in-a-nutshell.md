# Π in a nutshell

Christiano Braga  
Universidade Federal Fluminense  
http://www.ic.uff.br/~cbraga  
\
July 2019  
\
http://github.com/ChristianoBraga/PiFramework

## Introduction

Π is a simple semantic framework to teach compiler construction
principles. It is comprised of π IR, a language with
Turing-complete-expressive constructions, and Π automaton, a
stack-based machine that gives semantics to Π IR. To construct a
compiler for a language _L_, one needs to define Π denotations:
functions relating the (abstract) syntax of _L_ with Π IR
constructions.

## Π grammar

```
<IR> ::= <Statement>
<OC> ::= <ExpOC> | <CmdOC> | <DecOC> | <AbsOC>
```

## Π automata

A Π automaton is a 5-tuple _A = (G, Q, δ, q₀, F)_, where G is a
context-free grammar, Q is the set of states, q₀ is the initial state,
F ⊆ Q is the set of final states and _𝛅 : L(G)* × L(G)* × Store ⟶   Q_,
where _L(G)_ is the language generated by _G_ and _Store_ represents
the memory.

* Grammar _G_ is the result of the composition of Π IR and Π opcodes: _G = `<IR>` | `<OC>`_.  
* Elements in a set _S*_ are represented by terms _[s₁, s₂, ..., sᵢ]_.  
* 𝛅(∅, V, S) ∈ F, that is, it denotes an _accepting state_.

## Π IR expressions

### Grammar
```
<Statement>    ::= <Exp> 

<Exp>          ::= <ArithExp> | <BoolExp> | <Cont> | <Call/cc> | <Callf>

<ArithExp>     ::= Num(<digits>) | Sum(<Exp> , <Exp> ) | Sub(<Exp>, <Exp>) | 
                Mul(<Exp>, <Exp>) | Div(<Exp>, <Exp>)

<BoolExp>      ::= Boo(<bool>) | Eq(<Exp>, <Exp>) | Lt(<Exp>, <Exp>) | 
                Le(<Exp>, <Exp>) | Gt(<Exp>, <Exp>) | Ge(<Exp>, <Exp>) | 
                And(<Exp>, <Exp>) | Or(<Exp>, <Exp>) | Not(<Exp>) 

<bool>         ::= True | False

<Cont>		   ::= Cont(<Env>, <ValStack>, <ConStack>)

<Call/cc>	   ::= Call/cc(<Exp>)

<Callf>		   ::= Callf(<Exp>, <Actuals>)
```

### Opcodes
```
<ExpOC>     ::= #SUM | #SUB | #MUL | #DIV |   
                #EQ | #LT | #LE | #GT | #GE | #AND | #OR | #NOT |
                #CALLF
```

### Automaton

Recall that _𝛅 : L(G)* × L(G)* × Store ⟶   Q_, and let _N, Nᵢ ∈ ℕ_ ,
_B, Bᵢ ∈ Bool_, _C, V ∈ L(G)*_, _S ∈ Store_,

_𝛅(Num(N) :: C, V, S) = 𝛅(C, N :: V, S)_  
_𝛅(Sum(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #SUM :: C, V, S)_   
_𝛅(#SUM :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ + N₂ :: V, S)_

_𝛅(Sub(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #SUB :: C, V, S)_   
_𝛅(#SUB :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ - N₂ :: V, S)_

_𝛅(Mul(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #MUL :: C, V, S)_   
_𝛅(#MUL :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ * N₂ :: V, S)_

_𝛅(Div(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #MUL :: C, V, S)_   
_𝛅(#DIV :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ / N₂ :: V, S) if N₂ ≠ 0_

_𝛅(Eq(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #EQ :: C, V, S)_   
_𝛅(#EQ :: C, Boo(B₁) :: Boo(B₂) :: V, S) = 𝛅(C, B₁ = B₂ :: V, S)_

_𝛅(Lt(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #LT :: C, V, S)_   
_𝛅(#LT :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ < N₂ :: V, S)_

_𝛅(Le(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #LE :: C, V, S)_   
_𝛅(#LE :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ ≤ N₂ :: V, S)_

_𝛅(Gt(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #GT :: C, V, S)_   
_𝛅(#GT :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ > N₂ :: V, S)_

_𝛅(Ge(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #GE :: C, V, S)_   
_𝛅(#GE :: C, Num(N₁) :: Num(N₂) :: V, S) = 𝛅(C, N₁ ≥ N₂ :: V, S)_

_𝛅(And(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #AND :: C, V, S)_   
_𝛅(#AND :: C, Boo(B₁) :: Boo(B₂) :: V, S) = 𝛅(C, B₁ ∧ B₂ :: V, S)_

_𝛅(Or(E₁, E₂) :: C, V, S) = 𝛅(E₁ :: E₂ :: #OR :: C, V, S)_   
_𝛅(#OR :: C, Boo(B₁) :: Boo(B₂) :: V, S) = 𝛅(C, B₁ ∨ B₂ :: V, S)_

_𝛅(Not(E) :: C, V, S) = 𝛅(E :: #NOT :: C, V, S)_   
_𝛅(#NOT :: C, Boo(True) :: V, S) = 𝛅(C, False :: V, S)_   
_𝛅(#NOT :: C, Boo(False) :: V, S) = 𝛅(C, True :: V, S)_   

* Notation _h :: ls_ denotes the concatenation of element _h_ with the list _ls_. 

* _C_ represents the _control_ stack. _V_ represents the  _value_ stack. _S_ denotes the memory store.

* On a particular implementation of the Π Framework, as in Python,
`<digits>` and `<bool>` denote built-in numbers and Boolean values in
the chosen implementation language, such that all arithmetic
operations and Boolean operations, such as `+` and `or`, are defined.
That's why _Nᵢ_ are Natural numbers and _Bᵢ_ are Boolean values.

## Π IR commands

### Grammar

Commands are language constructions that require a _memory store_ to be evaluated. 

```
<Statement> ::= <Cmd> 

<Exp>       ::= Id(<String>) 
<Cmd>       ::= Nop | Assign(<Id>, <Exp>) | Loop(<BoolExp>, <Cmd>) | 
                CSeq(<Cmd>, <Cmd>) | Cond(<BoolExp>, <Cmd>, <Cmd>) | Ret(<Exp>)
```

### Opcodes
```
<CmdOC>     ::= #ASSIGN | #LOOP | #COND | #RET
```

### Automaton

* A location _l ∈ Loc_ denotes a memory cell.
* _Storable_ and _Bindable_ sets denote the data that may be mapped to
  by identifiers and locations on the memory and environment
  respectively.
* _Store = Id ↦ Storable_, _Env = Loc ↦ Bindable_, where A ↦ B denotes the
  finite map between sets A and B.
* _Loc ⊆ Storable_, _ℕ ⊆ Storable_, and _ℕ ⊆ Bindable_.
* The transition function is _𝛅 : L(G)* × L(G)* × Env × Store ⟶   Q_,
  and let _W ∈ String_, _C, V ∈ L(G)*_, _S ∈ Store_, _E ∈ Env_, _B ∈
  Bindable_, _l ∈ Loc_, _T ∈ Storable_, _X ∈ `<Exp>`_, _M, M₁, M₂ ∈
  `<Cmd>`_,and expression _S' = S/(l ↦ N)_ means that _S'_ equals to
  _S_ in all indices but _l_ where it is bound to _N_,

_𝛅(Id(W) :: C, V, E, S) = 𝛅(C, B :: V, E, S)_, **where** _E[W] = l ∧ S[l] = B_,

_𝛅(Assign(W, X) :: C, V, E, S) =  𝛅(X :: #ASSIGN :: C, W :: V, E, S')_,   
_𝛅(#ASSIGN :: C, T :: W :: V, E, S) = 𝛅(C, V, E, S')_, **where** _E[W] = l ∧ S' = S/(l ↦ T)_, 

_𝛅(Loop(X, M) :: C, V, E, S) =  𝛅(X :: #LOOP :: C, Loop(X, M) :: V, E, S)_,  
_𝛅(#LOOP :: C, true :: Loop(X, M) :: V, E, S) = 𝛅(M :: Loop(X, M) :: C, V, E, S)_,  
_𝛅(#LOOP :: C, false :: Loop(X, M) :: V, E, S) = 𝛅(C, V, E, S)_, 

_𝛅(Cond(X, M₁, M₂) :: C, V, E, S) =  𝛅(X :: #COND :: C, Cond(X, M₁, M₂) :: V, E, S)_,  
_𝛅(#COND :: C, true :: Cond(X, M₁, M₂) :: V, E, S) = 𝛅(M₁ :: C, V, E, S)_,  
_𝛅(#COND :: C, false :: Cond(X, M₁, M₂) :: V, E, S) = 𝛅(M₂ :: C, V, E, S)_, 

_𝛅(CSeq(M₁, M₂) :: C, V, E, S) = 𝛅(M₁ :: M₂ :: C, V, E, S)_.

𝛅(Cont(Env,Val,Con) :: C, V, E, S) = 𝛅(C,Cont(Env,Val,Con)::V, E, S)       (1)

𝛅(Call/cc(Func) :: C, V, E, S) = 𝛅(Callf(Func, Cont(E,V,C)) :: C,V, E, S)     (2)

𝛅( #CALLF :: C, Actual :: Cont(Env,Val,Con) :: V, E, S) = 𝛅(Con,Actual::Val, Env, S)   (3)

𝛅(Callf(Func, Actuals) :: C, V, E, S) = 𝛅(Func :: Actuals :: #CALLF :: C, Cont(E,V,C) :: V, E, S)    (4)

𝛅(Ret(Exp) :: C, V, E, S) = 𝛅(Exp :: #RET :: C, V, E, S)     (5)

𝛅(#RET :: C, Value :: ... :: Cont(Env,Val,Con) :: V, E, S) = 𝛅(Con, Value::Val, Env, S)    (6)



## Π IR declarations

### Grammar

* Declarations are statements that create an environment, binding identifiers to (bindable) values.
* In Π IR, a bindable value is either a Boolean value, an integer or a location. 
* From a syntactic standpoint, all classes are monotonically extended.

```
<Statement> ::= <Dec> 

<Exp>       ::= Ref(<Exp>)> | DeRef(<Id>) | ValRef(<Id>)

<Dec>       ::= Bind(<Id>, <Exp>) | DSeq(<Dec>, <Dec>)

<Cmd>       ::= Blk(<Dec>, <Cmd>) 
```

### Opcodes
```
<DecOC>     ::= #REF | #BLKDEC | #BLKCMD | #BIND | #DSEQ
```

### Automaton

Let _BlockLocs_ = 𝒫(Loc), the transition function be _𝛅 : L(G)* ×
L(G)* × Env × Store × BlockLocs ⟶   Q_, and let _L, L' ∈ BlockLocs_,
_Loc ⊆ Storable_, and _S / L = { l ↦ T | l ↦ T ∈ S ∧ l ∉ L}_, that
is, the store _S_ without the mappings whose locations are in _L_,

_𝛅(Ref(X) :: C, V, E, S, L) = 𝛅(X :: #REF :: C, V, E, S, L)_,   
_𝛅(#REF :: C, T :: V, E, S, L) = 𝛅(C, l :: V, E, S', L')_,   
   **where** _S' = S ∪ {l ↦ T}, l ∉ S, L' = L ∪ {l}_, 

_𝛅(DeRef(Id(W)) :: C, V, E, S, L) = 𝛅(C, l :: V, E, S, L)_, **where** _l = E[W]_,  

_𝛅(ValRef(Id(W)) :: C, V, E, S, L) = 𝛅(C, T :: V, E, S, L)_, **where** _T = S[S[E[W]]]_,  

_𝛅(Bind(Id(W), X) :: C, V, E, S, L) = 𝛅(X :: #BIND :: C, W :: V, E, S, L)_,   
_𝛅(#BIND :: C, B :: W :: E' :: V, E, S, L) = 𝛅(C, ({W ↦ B} ∪ E') :: V, E, S, L)_, **where** _E' ∈ Env_,  
_𝛅(#BIND :: C, B :: W :: H :: V, E, S, L) = 𝛅(C, {W ↦ B} :: H :: V, E, S, L)_, **where** _H ∉ Env_,  

_𝛅(DSeq(D₁, D₂), X) :: C, V, E, S, L) = 𝛅(D₁ :: D₂ :: C, V, E, S, L)_, 

_𝛅(Blk(D, M) :: C, V, E, S, L) = 𝛅(D :: #BLKDEC :: M :: #BLKCMD :: C, L :: V, E, S, ∅)_,  
_𝛅(#BLKDEC :: C, E' :: V, E, S, L) = 𝛅(C, E :: V, E / E', S, L)_,  
_𝛅(#BLKCMD :: C, E :: L :: V, E', S, L') = 𝛅(C, V, E, S', L)_, **where** _S' = S / L'_.

## Π IR abstractions

### Grammar

Abstractions extend Bindables by allowing a name to be bound to a list
of formal parameters, a list of identifiers, and a block in the
environment.  Such names can be called and applied to actual
parameters, a list of expressions.

```
<Dec>     ::= Bind(<Id>, <Abs>) 

<Abs>     ::= Abs(<Formals>, <Blk>) 

<Formals> ::= <Id>*

<Cmd>     ::= Call(<Id>, <Actuals>)

<Actuals> ::= <Exp>*
```

### Automaton

#### Closures

We chose a static binding semantics for abstractions. Therefore, we
interpret abstractions as _closures_ formed by an abstraction together
with its declaration environment which defines the context in which
the abstraction will be evaluated.

_Closure : Formals × Blk × Env ⟶   Bindable_ 

#### Abstractions

Let _F ∈ Formals_, _B ∈ Blk_, _I ∈ Id_, _A ∈ Actuals_, _Vᵢ ∈ Value_, _1 ≤ i ≤ u_, _u ∈ ℕ_,  

_𝛅(Abs(F, B) :: C, V, E, S, L) = 𝛅(C, Closure(F, B, E) :: V, E, S, L)_,   

_𝛅(Call(I, [X₁, X₂, ..., Xᵤ])) :: C, V, E, S, L)_ =  
   _𝛅(Xᵤ :: Xᵤ₋₁ :: ... :: X₁ :: #CALL(I, u) :: C, V, E, S, L)_,  
_𝛅(#CALL(I, u) ::C, V₁ :: V₂ :: ... :: Vᵤ :: V, E, S, L) =_  
    _𝛅(B :: #BLKCMD :: C, E :: L :: V, E', S, ∅)_,   
**where** _E = {I ↦ Closure(F, B, E₁)} ∪ E₂_,  
   _E'= E / E₁ / match(F, [V₁, V₂, ..., Vᵤ])_,

_match : Id* × Values* ⟶   Env_,  
_match(fl, al) = **if** |fl| ≠ |al| **than** {} **else** match-aux(fl, al, {})_,

_match-aux : Id* × Values* × Env ⟶   Env_,   
_match-aux([], [], E) = E_,    
_match-aux(f, a, E) = {f ↦ a} ∪ E_,  
_match-aux(f :: fl, a :: al, E) = match-aux(fl, al, {f ↦ a} ∪ E)_.


## Π IR recursive abstractions

### Grammar

```
<Dec> ::= Rbnd(<Id>, <Abs>) 
```

Automaton

#### Recursive closures

In the context of _static binding_ semantics for abstractions, in a call
to a recursive function, the evaluation of identifiers needs to be
"reminded" about the binding of the function name to a closure.

_Rec : Formals × Blk × Env × Env ⟶   Bindable_,  
_unfold : Env ⟶   Env_,  
_recloseₑ : Env ⟶   Env_,  

_unfold(e) = recloseₑ(e)_,  
_recloseₑ(I ↦ Closure(F, B, E′)) = (I ↦ Rec(F, B, E′, e))_,  
_recloseₑ(I ↦ Rec(F, B, E′, E′′)) = (I ↦ Rec(F, B, E′, e))_,  
_recloseₑ(I ↦ v) = (I ↦ v) if v ≠ Closure(F, B, E)_,  
_recloseₑ(e₁ ∪ e₂) = recloseₑ(e₁) ∪ recloseₑ(e₂)_,  
_recloseₑ(∅) = ∅_.  

#### Recursive abstractions 

_𝛅(Rbnd(I, Abs(F, B)) :: C, V, E, S, L) = 𝛅(#BIND :: C, unfold(I ↦ Closure(F, B, E)) :: V, E, S, L)_,  
_𝛅(#CALL(I, u) :: C, V₁ :: V₂ :: ... :: Vᵤ :: V, E, S, L) = 𝛅(B :: #BLKCMD :: C, E :: L :: V, E′, S, ∅)_,  
**where** _E = {I ↦ Rec(F, B, E₁, E₂)} ∪ E₃_,  
   _E' = E / E₁ / unfold(E₂) / match(F, [V₁, V₂, ..., Vᵤ])_.  



### Example of call/cc

𝛅(Print(Call/cc(Id("g"))) :: [], [], {"g" ↦ Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, {}, [])

=

𝛅(Call/cc(Id("g")) :: #PRINT :: [], [], {"g" ↦ Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, {}, [])

= using rule 2

𝛅(Callf(Id("g"), Cont({"g" ↦ Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, [], #PRINT :: []))::#PRINT :: [], [], {"g" ↦ Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, {}, [])

= using rule 4

𝛅(Id("g") :: Cont({"g" ↦ Abs(Id("k") :: [],Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, [], #PRINT :: []) :: #CALLF :: #PRINT :: [],Cont({"g" ↦ Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, [], #PRINT :: []) :: [], {"g" ↦ Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, {}, []))

=

𝛅(Cont({"g" ↦ Abs(Id("k") :: [],Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, [], #PRINT :: []) :: #CALLF :: #PRINT :: [],Abs(Id("k") :: [],Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))::Cont({"g" ↦ Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, [], #PRINT :: []) :: [], {"g" ↦ Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, {}, []))

= using rule 1

𝛅(#CALLF :: #PRINT :: [],Cont({"g" ↦ Abs(Id("k") :: [],Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, [], #PRINT :: []) :: Abs(Id("k") :: [],Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))::Cont({"g" ↦ Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, [], #PRINT :: []) :: [], {"g" ↦ Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))}, {}, []))

To preserve readbility, let's make gBody as Abs(Id("k"),Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))

= 

𝛅(#CALLF :: #PRINT :: [],Cont({"g" ↦ gBody}, [], #PRINT :: []) :: gBody::Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"g" ↦ gBody}, {}, []))

=

𝛅(Blk(Bind(Id("k"),ref(Cont({"g" ↦ gBody}, [], #PRINT :: [])), Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45))))))) :: #PRINT :: [],Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"g" ↦ gBody}, {}, []))

=

𝛅(Bind(Id("k"), Ref(Cont({"g" ↦ gBody}, [], #PRINT :: [])) :: Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45)))))))) :: #BLK :: #PRINT :: [],  {"g" ↦ gBody} :: Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"g" ↦ gBody}, {}, []))

=

𝛅(Ref(Cont({"g" ↦ gBody}, [], #PRINT :: [])) :: Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45)))))))) :: #BIND :: #BLK :: #PRINT :: [],  Id("k") :: {"g" ↦ gBody} :: Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"g" ↦ gBody}, {}, []))

=

𝛅(Cont({"g" ↦ gBody}, [], #PRINT :: []) :: #REF :: #BIND :: Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45)))))) :: #BLK :: #PRINT :: [],Id("k") :: Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"g" ↦ gBody}, {}, []))

= using rule 1

𝛅( #REF :: #BIND :: Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45)))))) :: #BLK :: #PRINT :: [],Cont({"g" ↦ gBody}, [], #PRINT :: []) :: Id("k") :: Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"g" ↦ gBody}, {}, []))

=

𝛅( l1 :: #BIND :: Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45)))))) :: #BLK :: #PRINT :: [], Id("k") :: Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"g" ↦ gBody}, {l1 ↦ Cont({"g" ↦ gBody}, [], #PRINT :: [])}, []))

=

𝛅( Blk(EmptyDec, CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45)))))) :: #BLK :: #PRINT :: [], Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"k"↦l1 ,"g" ↦ gBody}, {l1 ↦ Cont({"g" ↦ gBody}, [], #PRINT :: [])}, [l1]))

=

𝛅( EmptyDec :: CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45)))))) :: #BLK :: #BLK :: #PRINT :: [], {"k"↦l1 ,"g" ↦ gBody} :: Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"k"↦l1 ,"g" ↦ gBody}, {l1 ↦ Cont({"g" ↦ gBody}, [], #PRINT :: [])}, [l1]))

=

𝛅( CSeq(Callf(Id("k"),Num(2)), CSeq(Print(Num(3)), Ret(Num(45)))))) :: #BLK :: #BLK :: #PRINT :: [], Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"k"↦l1 ,"g" ↦ gBody}, {l1 ↦ Cont({"g" ↦ gBody}, [], #PRINT :: [])}, [l1]))

=

𝛅( Callf(Id("k"),Num(2)) :: CSeq(Print(Num(3)), Ret(Num(45))) :: #BLK :: #BLK :: #PRINT :: [], Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"k"↦l1 ,"g" ↦ gBody}, {l1 ↦ Cont({"g" ↦ gBody}, [], #PRINT :: [])}, [l1]))

=

𝛅( Id("k") :: Num(2) :: #CALLF :: CSeq(Print(Num(3)), Ret(Num(45))) :: #BLK :: #BLK :: #PRINT :: [], Cont({"k"↦l1 ,"g" ↦ gBody}, Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], CSeq(Print(Num(3)), Ret(Num(45))) :: #BLK :: #BLK :: #PRINT :: []) :: Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"k"↦l1 ,"g" ↦ gBody}, {l1 ↦ Cont({"g" ↦ gBody}, [], #PRINT :: [])}, [l1]))

=

𝛅( Num(2) :: #CALLF :: CSeq(Print(Num(3)), Ret(Num(45))) :: #BLK :: #BLK :: #PRINT :: [], Cont({"g" ↦ gBody}, [], #PRINT :: []) :: Cont({"k"↦l1 ,"g" ↦ gBody}, Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], CSeq(Print(Num(3)), Ret(Num(45))) :: #BLK :: #BLK :: #PRINT :: []) :: Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"k"↦l1 ,"g" ↦ gBody}, {l1 ↦ Cont({"g" ↦ gBody}, [], #PRINT :: [])}, [l1]))

=

<u>***𝛅( #CALLF :: CSeq(Print(Num(3)), Ret(Num(45))) :: #BLK :: #BLK :: #PRINT :: [], Num(2) :: Cont({"g" ↦ gBody}, [], #PRINT :: []) :: Cont({"k"↦l1 ,"g" ↦ gBody}, Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], CSeq(Print(Num(3)), Ret(Num(45))) :: #BLK :: #BLK :: #PRINT :: []) :: Cont({"g" ↦ gBody}, [], #PRINT :: []) :: [], {"k"↦l1 ,"g" ↦ gBody}, {l1 ↦ Cont({"g" ↦ gBody}, [], #PRINT :: [])}, [l1]))***</u>

<u>***=***</u> using rule 3

<u>***𝛅(#PRINT :: [], Num(2) :: [], {"g" ↦ gBody}, {l1 ↦ Cont({"g" ↦ gBody}, [], #PRINT :: [])}, [l1])***</u>


OUTPUT : <u>***2***</u>



